MODULE asminc
   !!======================================================================
   !!                       ***  MODULE asminc  ***
   !! Assimilation increment : Apply an increment generated by data
   !!                          assimilation
   !!======================================================================
   !! History :       ! 2007-03  (M. Martin)  Met Office version
   !!                 ! 2007-04  (A. Weaver)  calc_date original code
   !!                 ! 2007-04  (A. Weaver)  Merge with OPAVAR/NEMOVAR
   !!   NEMO     3.3  ! 2010-05  (D. Lea)  Update to work with NEMO v3.2
   !!             -   ! 2010-05  (D. Lea)  add calc_month_len routine based on day_init
   !!            3.4  ! 2012-10  (A. Weaver and K. Mogensen) Fix for direct initialization
   !!                 ! 2014-09  (D. Lea)  Local calc_date removed use routine from OBS
   !!                 ! 2015-11  (D. Lea)  Handle non-zero initial time of day
   !!----------------------------------------------------------------------

   !!----------------------------------------------------------------------
   !!   asm_inc_init   : Initialize the increment arrays and IAU weights
   !!   tra_asm_inc    : Apply the tracer (T and S) increments
   !!   dyn_asm_inc    : Apply the dynamic (u and v) increments
   !!   ssh_asm_inc    : Apply the SSH increment
   !!   ssh_asm_div    : Apply divergence associated with SSH increment
   !!   sic_asm_inc    : Apply the sea-ice concentration increment
   !!   sit_asm_inc    : Apply the sea-ice thickness increment
   !!----------------------------------------------------------------------
   USE oce             ! Dynamics and active tracers defined in memory
   USE par_oce         ! Ocean space and time domain variables
   USE dom_oce         ! Ocean space and time domain
   USE ldfdyn          ! lateral diffusion: eddy viscosity coefficients
   USE eosbn2          ! Equation of state - in situ and potential density
   USE asmpar          ! Parameters for the assmilation interface
   USE asmbkg          !
   USE c1d             ! 1D initialization
   USE sbc_oce         ! Surface boundary condition variables.
   USE diaobs   , ONLY : calc_date     ! Compute the calendar date on a given step
#if defined key_si3 && defined key_asminc
   USE phycst         ! physical constants
   USE ice1D          ! sea-ice: thermodynamics variables
   USE icetab         ! sea-ice: 3D <==> 2D, 2D <==> 1D
   USE ice
#endif
   !
   USE in_out_manager  ! I/O manager
   USE iom             ! Library to read input files
   USE lib_mpp         ! MPP library

   IMPLICIT NONE
   PRIVATE

   PUBLIC   asm_inc_init   !: Initialize the increment arrays and IAU weights
   PUBLIC   tra_asm_inc    !: Apply the tracer (T and S) increments
   PUBLIC   dyn_asm_inc    !: Apply the dynamic (u and v) increments
   PUBLIC   ssh_asm_inc    !: Apply the SSH increment
   PUBLIC   ssh_asm_div    !: Apply the SSH divergence
   PUBLIC   sic_asm_inc    !: Apply the sea-ice concentration increment
   PUBLIC   sit_asm_inc    !: Apply the sea-ice thickness increment

#if defined key_asminc
    LOGICAL, PUBLIC, PARAMETER :: lk_asminc = .TRUE.   !: Logical switch for assimilation increment interface
#else
    LOGICAL, PUBLIC, PARAMETER :: lk_asminc = .FALSE.  !: No assimilation increments
#endif

   LOGICAL, PUBLIC :: ln_bkgwri     !: Logical switch for writing out background state
   LOGICAL, PUBLIC :: ln_asmiau     !: Logical switch for Incremental Analysis Updating (IAU)
   LOGICAL, PUBLIC :: ln_asmdin     !: Logical switch for Direct Initialization (DI)
   LOGICAL, PUBLIC :: ln_trainc     !: Logical switch for applying tracer increments
   LOGICAL, PUBLIC :: ln_dyninc     !: Logical switch for applying velocity increments
   LOGICAL, PUBLIC :: ln_sshinc     !: Logical switch for applying SSH increments
   LOGICAL, PUBLIC :: ln_sicinc     !: No sea ice concentration increment
   LOGICAL, PUBLIC :: ln_sitinc     !: No sea ice thickness increment
   LOGICAL, PUBLIC :: ln_salfix     !: Logical switch for ensuring that the sa > salfixmin
   LOGICAL, PUBLIC :: ln_temnofreeze!: Don't allow the temperature to drop below freezing
   LOGICAL, PUBLIC :: ln_bv_check = .FALSE.    !: Don't apply T/S increments where Brunt-Vaisala (N2) checks fail
   INTEGER, PUBLIC :: nn_divdmp     !: Number of iterations of divergence damping operator

   REAL(wp), PUBLIC, DIMENSION(:,:,:), ALLOCATABLE ::   t_bkg   , s_bkg      !: Background temperature and salinity
   REAL(wp), PUBLIC, DIMENSION(:,:,:), ALLOCATABLE ::   u_bkg   , v_bkg      !: Background u- & v- velocity components
   REAL(wp), PUBLIC, DIMENSION(:,:,:), ALLOCATABLE ::   t_bkginc, s_bkginc   !: Increment to the background T & S
   REAL(wp), PUBLIC, DIMENSION(:,:,:), ALLOCATABLE ::   u_bkginc, v_bkginc   !: Increment to the u- & v-components
   REAL(wp), PUBLIC, DIMENSION(:)    , ALLOCATABLE ::   wgtiau               !: IAU weights for each time step
#if defined key_asminc
   REAL(wp), PUBLIC, DIMENSION(:,:)  , ALLOCATABLE ::   ssh_iau              !: IAU-weighted sea surface height increment
#endif
   !                                !!! time steps relative to the cycle interval [0,nitend-nit000-1]
   INTEGER , PUBLIC ::   nn_itbkg     !: Time step of the background state used in the Jb term
   INTEGER , PUBLIC ::   nn_itdin     !: Time step of the background state for direct initialization
   INTEGER , PUBLIC ::   nn_itiaustr  !: Time step of the start of the IAU interval
   INTEGER , PUBLIC ::   nn_itiaufin  !: Time step of the end of the IAU interval
   !
   INTEGER , PUBLIC ::   nn_iaufn     !: Type of IAU weighing function: = 0   Constant weighting
   !                                  !  = 1   Linear hat-like, centred in middle of IAU interval
   REAL(wp), PUBLIC ::   rn_salfixmin !: Ensure that the salinity is larger than this  value if (ln_salfix)
   REAL(wp), PUBLIC ::   rn_bv_thres  !: Brunt-Vaisala threshold for applying T/S increments
   REAL(wp), PUBLIC ::   rn_zmin_bv   !: Min depth to verify Brunt-Vaisala (N2) values
   REAL(wp), PUBLIC ::   rn_zmax_bv   !: Max depth to verify Brunt-Vaisala (N2) values

   REAL(wp), DIMENSION(:,:), ALLOCATABLE ::   ssh_bkg, ssh_bkginc   ! Background sea surface height and its increment
   REAL(wp), DIMENSION(:,:), ALLOCATABLE ::   sic_bkginc            ! Increment to the background sea ice concentration
   REAL(wp), DIMENSION(:,:), ALLOCATABLE ::   sit_bkginc            ! Increment to the background sea ice thickness
   REAL(wp) :: rn_zhi_damin                                         ! Ice thickness for new sea ice from DA increment
   REAL(wp) :: rn_ai_damin                                          ! Minimum total ice concentration to apply thickness DA
   REAL(wp) :: rn_acat_damin                                        ! Minimum ice concentration at category level to apply
                                                                    ! thickness DA increments
#if defined key_si3 && defined key_asminc
   REAL(wp), DIMENSION(:,:,:), ALLOCATABLE ::   a_i_bkginc          ! Increment to the background sea ice conc categories
   LOGICAL, PUBLIC, DIMENSION(:,:,:), ALLOCATABLE :: lincr_newice   !: Mask .TRUE.=DA positive ice increment to open water
#endif
#if defined key_cice && defined key_asminc
   REAL(wp), DIMENSION(:,:), ALLOCATABLE ::   ndaice_da             ! ice increment tendency into CICE
#endif

   !! * Substitutions
#  include "do_loop_substitute.h90"
#  include "read_nml_substitute.h90"
#  include "domzgr_substitute.h90"
   !!----------------------------------------------------------------------
   !! NEMO/OCE 4.0 , NEMO Consortium (2018)
   !! $Id: asminc.F90 15058 2021-06-25 09:15:15Z clem $
   !! Software governed by the CeCILL license (see ./LICENSE)
   !!----------------------------------------------------------------------
CONTAINS

   SUBROUTINE asm_inc_init( Kbb, Kmm, Krhs )
      !!----------------------------------------------------------------------
      !!                    ***  ROUTINE asm_inc_init  ***
      !!
      !! ** Purpose : Initialize the assimilation increment and IAU weights.
      !!
      !! ** Method  : Initialize the assimilation increment and IAU weights.
      !!
      !! ** Action  :
      !!----------------------------------------------------------------------
      INTEGER, INTENT(in) ::  Kbb, Kmm, Krhs  ! time level indices
      !
      INTEGER :: ji, jj, jk, jt, jl     ! dummy loop indices
      INTEGER :: imid, inum             ! local integers
      INTEGER :: ios                    ! Local integer output status for namelist read
      INTEGER :: iiauper                ! Number of time steps in the IAU period
      INTEGER :: icycper                ! Number of time steps in the cycle
      REAL(dp) ::   dlditend_date      ! Date YYYYMMDD.HHMMSS of final time step
      REAL(dp) ::   dlditbkg_date      ! Date YYYYMMDD.HHMMSS of background time step for Jb term
      REAL(dp) ::   dlditdin_date      ! Date YYYYMMDD.HHMMSS of background time step for DI
      REAL(dp) ::   dlditiaustr_date   ! Date YYYYMMDD.HHMMSS of IAU interval start time step
      REAL(dp) ::   dlditiaufin_date   ! Date YYYYMMDD.HHMMSS of IAU interval final time step
      !
      REAL(wp) :: znorm        ! Normalization factor for IAU weights
      REAL(wp) :: ztotwgt      ! Value of time-integrated IAU weights (should be equal to one)
      REAL(wp) :: z_inc_dateb  ! Start date of interval on which increment is valid
      REAL(wp) :: z_inc_datef  ! End date of interval on which increment is valid
      REAL(wp) :: zdate_bkg    ! Date in background state file for DI
      REAL(wp) :: zdate_inc    ! Time axis in increments file
      !
      REAL(wp), PARAMETER ::   pplarge = 1e10_wp   ! Large number
      REAL(wp), PARAMETER ::   ppsmall = 1e-3_wp   ! Small number
      !
      REAL(wp), ALLOCATABLE, DIMENSION(:,:) ::   zhdiv   ! 2D workspace
      REAL(wp) :: zremaining_increment
      !!
      NAMELIST/nam_asminc/ ln_bkgwri, ln_trainc, ln_dyninc, ln_sshinc,     &
         &                 ln_sicinc, ln_sitinc, ln_asmdin, ln_asmiau,     &
         &                 nn_itbkg, nn_itdin, nn_itiaustr, nn_itiaufin,   &
         &                 nn_iaufn, ln_bv_check, rn_bv_thres, rn_zmin_bv, &
         &                 rn_zmax_bv, ln_salfix, rn_salfixmin,            &
         &                 ln_temnofreeze, nn_divdmp,                      &
         &                 rn_zhi_damin, rn_ai_damin, rn_acat_damin
      !!----------------------------------------------------------------------

      !-----------------------------------------------------------------------
      ! Read Namelist nam_asminc : assimilation increment interface
      !-----------------------------------------------------------------------
      ln_sicinc      = .FALSE.
      ln_sitinc      = .FALSE.
      READ_NML_REF(numnam,nam_asminc)
      READ_NML_CFG(numnam,nam_asminc)
      IF(lwm) WRITE ( numond, nam_asminc )

      ! Control print
      IF(lwp) THEN
         WRITE(numout,*)
         WRITE(numout,*) 'asm_inc_init : Assimilation increment initialization :'
         WRITE(numout,*) '~~~~~~~~~~~~'
         WRITE(numout,*) '   Namelist namasm : set assimilation increment parameters'
         WRITE(numout,*) '      Logical switch for writing out background state          ln_bkgwri     = ', ln_bkgwri
         WRITE(numout,*) '      Logical switch for applying tracer increments            ln_trainc     = ', ln_trainc
         WRITE(numout,*) '      Logical switch for applying velocity increments          ln_dyninc     = ', ln_dyninc
         WRITE(numout,*) '      Logical switch for applying SSH increments               ln_sshinc     = ', ln_sshinc
         WRITE(numout,*) '      Logical switch for Direct Initialization (DI)            ln_asmdin     = ', ln_asmdin
         WRITE(numout,*) '      Logical switch for applying ice concentration increments ln_sicinc     = ', ln_sicinc
         WRITE(numout,*) '      Logical switch for applying ice thickness increments     ln_sitinc     = ', ln_sitinc
         WRITE(numout,*) '      Logical switch for Incremental Analysis Updating (IAU)   ln_asmiau     = ', ln_asmiau
         WRITE(numout,*) '      Logical switch to use Brunt-Vaisala to reject T/S inc    ln_bv_check   = ', ln_bv_check
         WRITE(numout,*) '      Timestep of background in [0,nitend-nit000-1]            nn_itbkg      = ', nn_itbkg
         WRITE(numout,*) '      Timestep of background for DI in [0,nitend-nit000-1]     nn_itdin      = ', nn_itdin
         WRITE(numout,*) '      Timestep of start of IAU interval in [0,nitend-nit000-1] nn_itiaustr   = ', nn_itiaustr
         WRITE(numout,*) '      Timestep of end of IAU interval in [0,nitend-nit000-1]   nn_itiaufin   = ', nn_itiaufin
         WRITE(numout,*) '      Type of IAU weighting function                           nn_iaufn      = ', nn_iaufn
         WRITE(numout,*) '      Number of iterations of divergence damping operator      nn_divdmp     = ', nn_divdmp
         WRITE(numout,*) '      Logical switch for ensuring that the sa > salfixmin      ln_salfix     = ', ln_salfix
         WRITE(numout,*) '      Do not apply negative increments if the T < freezing     ln_temnofreeze = ',ln_temnofreeze
         WRITE(numout,*) '      Minimum salinity after applying the increments           rn_salfixmin  = ', rn_salfixmin
         WRITE(numout,*) '      Minimum ice thickness for new ice from DA                rn_zhi_damin  = ', rn_zhi_damin
         WRITE(numout,*) '      Minimum total ice conc required for applying sit inc     rn_ai_damin   = ', rn_ai_damin
         WRITE(numout,*) '      Minimum category ice conc required for applying sit inc  rn_acat_damin = ', rn_acat_damin
         WRITE(numout,*) '      Brunt-Vaisala threshold to reject T/S increments         rn_bv_thres   = ', rn_bv_thres
         WRITE(numout,*) '      Min depth to verify Brunt-Vaisala values                 rn_zmin_bv    = ', rn_zmin_bv
         WRITE(numout,*) '      Max depth to verify Brunt-Vaisala values                 rn_zmax_bv    = ', rn_zmax_bv
      ENDIF

      nitbkg_r    = nn_itbkg    + nit000 - 1            ! Background time referenced to nit000
      nitdin_r    = nn_itdin    + nit000 - 1            ! Background time for DI referenced to nit000
      nitiaustr_r = nn_itiaustr + nit000 - 1            ! Start of IAU interval referenced to nit000
      nitiaufin_r = nn_itiaufin + nit000 - 1            ! End of IAU interval referenced to nit000

      iiauper     = nitiaufin_r - nitiaustr_r + 1     ! IAU interval length
      icycper     = nitend      - nit000      + 1     ! Cycle interval length

      CALL calc_date( nitend     , dlditend_date    )   ! Date of final time step
      CALL calc_date( nitbkg_r   , dlditbkg_date    )   ! Background time for Jb referenced to ndate0
      CALL calc_date( nitdin_r   , dlditdin_date    )   ! Background time for DI referenced to ndate0
      CALL calc_date( nitiaustr_r, dlditiaustr_date )   ! IAU start time referenced to ndate0
      CALL calc_date( nitiaufin_r, dlditiaufin_date )   ! IAU end time referenced to ndate0

      IF(lwp) THEN
         WRITE(numout,*)
         WRITE(numout,*) '   Time steps referenced to current cycle:'
         WRITE(numout,*) '       iitrst      = ', nit000 - 1
         WRITE(numout,*) '       nit000      = ', nit000
         WRITE(numout,*) '       nitend      = ', nitend
         WRITE(numout,*) '       nitbkg_r    = ', nitbkg_r
         WRITE(numout,*) '       nitdin_r    = ', nitdin_r
         WRITE(numout,*) '       nitiaustr_r = ', nitiaustr_r
         WRITE(numout,*) '       nitiaufin_r = ', nitiaufin_r
         WRITE(numout,*)
         WRITE(numout,*) '   Dates referenced to current cycle:'
         WRITE(numout,*) '       ndastp           = ', ndastp
         WRITE(numout,*) '       ndate0           = ', ndate0
         WRITE(numout,*) '       nn_time0         = ', nn_time0
         WRITE(numout,*) '       dlditend_date    = ', dlditend_date
         WRITE(numout,*) '       dlditbkg_date    = ', dlditbkg_date
         WRITE(numout,*) '       dlditdin_date    = ', dlditdin_date
         WRITE(numout,*) '       dlditiaustr_date = ', dlditiaustr_date
         WRITE(numout,*) '       dlditiaufin_date = ', dlditiaufin_date
      ENDIF


      IF ( ( ln_asmdin ).AND.( ln_asmiau ) )   &
         & CALL ctl_stop( ' ln_asmdin and ln_asmiau :', &
         &                ' Choose Direct Initialization OR Incremental Analysis Updating')

      IF (      ( ( .NOT. ln_asmdin ).AND.( .NOT. ln_asmiau ) ) &
           .AND.( ( ln_trainc ).OR.( ln_dyninc ).OR.( ln_sshinc ) .OR. ( ln_sicinc ) .OR. ( ln_sitinc ) )) &
         & CALL ctl_stop( ' One or more of ln_trainc, ln_dyninc, ln_sshinc, ln_sicinc, ln_sitinc is set to .true.', &
         &                ' but ln_asmdin and ln_asmiau are both set to .false. :', &
         &                ' Inconsistent options')

      IF ( ( nn_iaufn /= 0 ).AND.( nn_iaufn /= 1 ) ) &
         & CALL ctl_stop( ' nn_iaufn /= 0 or nn_iaufn /=1 :',  &
         &                ' Type IAU weighting function is invalid')

      IF ( ( .NOT. ln_trainc ).AND.( .NOT. ln_dyninc ).AND.( .NOT. ln_sshinc ).AND.( .NOT. ln_sicinc ) &
         & .AND.( .NOT. ln_sitinc ) )  &
         & CALL ctl_warn( ' ln_trainc, ln_dyninc, ln_sshinc, ln_sicinc and ln_sitinc are set to .false. :', &
         &                ' The assimilation increments are not applied')

      IF ( ( ln_asmiau ).AND.( nn_itiaustr == nn_itiaufin ) ) &
         & CALL ctl_stop( ' nn_itiaustr = nn_itiaufin :',  &
         &                ' IAU interval is of zero length')

      IF ( ( ln_asmiau ).AND.( ( nitiaustr_r < nit000 ).OR.( nitiaufin_r > nitend ) ) ) &
         & CALL ctl_stop( ' nitiaustr or nitiaufin :',  &
         &                ' IAU starting or final time step is outside the cycle interval', &
         &                 ' Valid range nit000 to nitend')

      IF ( ( nitbkg_r < nit000 - 1 ).OR.( nitbkg_r > nitend ) ) &
         & CALL ctl_stop( ' nn_itbkg :',  &
         &                ' Background time step is outside the cycle interval')

      IF ( ( nitdin_r < nit000 - 1 ).OR.( nitdin_r > nitend ) ) &
         & CALL ctl_stop( ' nn_itdin :',  &
         &                ' Background time step for Direct Initialization is outside', &
         &                ' the cycle interval')

      IF ( nstop > 0 ) RETURN       ! if there are any errors then go no further

      !--------------------------------------------------------------------
      ! Initialize the Incremental Analysis Updating weighting function
      !--------------------------------------------------------------------

      IF( ln_asmiau ) THEN
         !
         ALLOCATE( wgtiau( icycper ) )
         !
         wgtiau(:) = 0._wp
         !
         !                                !---------------------------------------------------------
         IF( nn_iaufn == 0 ) THEN         ! Constant IAU forcing
            !                             !---------------------------------------------------------
            DO jt = 1, iiauper
               wgtiau(jt+nn_itiaustr-1) = 1.0_wp / REAL( iiauper, KIND=wp )
            END DO
            !                             !---------------------------------------------------------
         ELSEIF ( nn_iaufn == 1 ) THEN    ! Linear hat-like, centred in middle of IAU interval
            !                             !---------------------------------------------------------
            ! Compute the normalization factor
            znorm = 0._wp
            IF( MOD( iiauper, 2 ) == 0 ) THEN   ! Even number of time steps in IAU interval
               imid = iiauper / 2
               DO jt = 1, imid
                  znorm = znorm + REAL( jt )
               END DO
               znorm = 2.0 * znorm
            ELSE                                ! Odd number of time steps in IAU interval
               imid = ( iiauper + 1 ) / 2
               DO jt = 1, imid - 1
                  znorm = znorm + REAL( jt )
               END DO
               znorm = 2.0 * znorm + REAL( imid )
            ENDIF
            znorm = 1.0 / znorm
            !
            DO jt = 1, imid - 1
               wgtiau(jt+nn_itiaustr-1) = REAL( jt ) * znorm
            END DO
            DO jt = imid, iiauper
               wgtiau(jt+nn_itiaustr-1) = REAL( iiauper - jt + 1 ) * znorm
            END DO
            !
         ENDIF

         ! Test that the integral of the weights over the weighting interval equals 1
          IF(lwp) THEN
             WRITE(numout,*)
             WRITE(numout,*) 'asm_inc_init : IAU weights'
             WRITE(numout,*) '~~~~~~~~~~~~'
             WRITE(numout,*) '             time step         IAU  weight'
             WRITE(numout,*) '             =========     ====================='
             ztotwgt = 0.0
             DO jt = 1, icycper
                ztotwgt = ztotwgt + wgtiau(jt)
                WRITE(numout,*) '         ', jt, '       ', wgtiau(jt)
             END DO
             WRITE(numout,*) '         ==================================='
             WRITE(numout,*) '         Time-integrated weight = ', ztotwgt
             WRITE(numout,*) '         ==================================='
          ENDIF

      ENDIF

      !--------------------------------------------------------------------
      ! Allocate and initialize the increment arrays
      !--------------------------------------------------------------------

      ALLOCATE( t_bkginc     (jpi,jpj,jpk) )   ;   t_bkginc     (:,:,:) = 0._wp
      ALLOCATE( s_bkginc     (jpi,jpj,jpk) )   ;   s_bkginc     (:,:,:) = 0._wp
      ALLOCATE( u_bkginc     (jpi,jpj,jpk) )   ;   u_bkginc     (:,:,:) = 0._wp
      ALLOCATE( v_bkginc     (jpi,jpj,jpk) )   ;   v_bkginc     (:,:,:) = 0._wp
      ALLOCATE( ssh_bkginc   (jpi,jpj)     )   ;   ssh_bkginc   (:,:)   = 0._wp
      ALLOCATE( sic_bkginc   (jpi,jpj)     )   ;   sic_bkginc   (:,:)   = 0._wp
      ALLOCATE( sit_bkginc(jpi,jpj)        )   ;   sit_bkginc   (:,:)   = 0._wp
#if defined key_si3 && defined key_asminc
      ALLOCATE( a_i_bkginc   (jpi,jpj,jpl) )   ;   a_i_bkginc   (:,:,:) = 0._wp
      ALLOCATE( lincr_newice(jpi,jpj,jpl) )    ;   lincr_newice (:,:,:) = .FALSE.
#endif
#if defined key_asminc
      ALLOCATE( ssh_iau      (jpi,jpj)     )   ;   ssh_iau      (:,:)   = 0._wp
#endif
#if defined key_cice && defined key_asminc
      ALLOCATE( ndaice_da    (jpi,jpj)     )   ;   ndaice_da    (:,:)   = 0._wp
#endif
      !
      IF ( ln_trainc .OR. ln_dyninc .OR.   &                   !--------------------------------------
         & ln_sshinc .OR. ln_sicinc .OR. ln_sitinc   ) THEN    ! Read the increments from file
         !                                                     !--------------------------------------
         CALL iom_open( c_asminc, inum )
         !
         CALL iom_get( inum, 'time'       , zdate_inc   )
         CALL iom_get( inum, 'z_inc_dateb', z_inc_dateb )
         CALL iom_get( inum, 'z_inc_datef', z_inc_datef )
         z_inc_dateb = zdate_inc
         z_inc_datef = zdate_inc
         !
         IF(lwp) THEN
            WRITE(numout,*)
            WRITE(numout,*) 'asm_inc_init : Assimilation increments valid between dates ', z_inc_dateb,' and ', z_inc_datef
            WRITE(numout,*) '~~~~~~~~~~~~'
         ENDIF
         !
         IF ( ( z_inc_dateb < ndastp + nn_time0*0.0001_wp ) .OR.   &
            & ( z_inc_datef > dlditend_date ) ) &
            &    CALL ctl_warn( ' Validity time of assimilation increments is ', &
            &                   ' outside the assimilation interval' )

         IF ( ( ln_asmdin ).AND.( zdate_inc /= dlditdin_date ) ) &
            & CALL ctl_warn( ' Validity time of assimilation increments does ', &
            &                ' not agree with Direct Initialization time' )

         IF ( ln_trainc ) THEN
            CALL iom_get( inum, jpdom_auto, 'bckint', t_bkginc, 1 )
            CALL iom_get( inum, jpdom_auto, 'bckins', s_bkginc, 1 )
            ! Apply the masks
            t_bkginc(:,:,:) = t_bkginc(:,:,:) * tmask(:,:,:)
            s_bkginc(:,:,:) = s_bkginc(:,:,:) * tmask(:,:,:)
            ! Set missing increments to 0.0 rather than 1e+20
            ! to allow for differences in masks
            WHERE( ABS( t_bkginc(:,:,:) ) > pplarge ) t_bkginc(:,:,:) = 0.0_wp
            WHERE( ABS( s_bkginc(:,:,:) ) > pplarge ) s_bkginc(:,:,:) = 0.0_wp
         ENDIF

         IF ( ln_dyninc ) THEN
            CALL iom_get( inum, jpdom_auto, 'bckinu', u_bkginc, 1, cd_type = 'U', psgn = -1._wp )
            CALL iom_get( inum, jpdom_auto, 'bckinv', v_bkginc, 1, cd_type = 'V', psgn = -1._wp )
            ! Apply the masks
            u_bkginc(:,:,:) = u_bkginc(:,:,:) * umask(:,:,:)
            v_bkginc(:,:,:) = v_bkginc(:,:,:) * vmask(:,:,:)
            ! Set missing increments to 0.0 rather than 1e+20
            ! to allow for differences in masks
            WHERE( ABS( u_bkginc(:,:,:) ) > pplarge ) u_bkginc(:,:,:) = 0.0_wp
            WHERE( ABS( v_bkginc(:,:,:) ) > pplarge ) v_bkginc(:,:,:) = 0.0_wp
         ENDIF

         IF ( ln_sshinc ) THEN
            CALL iom_get( inum, jpdom_auto, 'bckineta', ssh_bkginc, 1 )
            ! Apply the masks
            ssh_bkginc(:,:) = ssh_bkginc(:,:) * tmask(:,:,1)
            ! Set missing increments to 0.0 rather than 1e+20
            ! to allow for differences in masks
            WHERE( ABS( ssh_bkginc(:,:) ) > pplarge ) ssh_bkginc(:,:) = 0.0_wp
         ENDIF

         IF ( ln_sitinc ) THEN
            CALL iom_get( inum, jpdom_auto, 'bckinsit', sit_bkginc, 1 )
            ! Apply the masks
            sit_bkginc(:,:) = sit_bkginc(:,:) * tmask(:,:,1)
            ! Set missing increments to 0.0 rather than 1e+20
            ! to allow for differences in masks
            WHERE( ABS( sit_bkginc(:,:) ) > pplarge ) sit_bkginc(:,:) = 0.0_wp
         ENDIF

         IF ( ln_sicinc ) THEN
            CALL iom_get( inum, jpdom_auto, 'bckinseaice', sic_bkginc, 1 )
            ! Apply the masks
            sic_bkginc(:,:) = sic_bkginc(:,:) * tmask(:,:,1)
            ! Set missing increments to 0.0 rather than 1e+20
            ! to allow for differences in masks
            ! very small increments are also set to zero
            WHERE( ABS( sic_bkginc(:,:) ) > pplarge .OR. &
              &    ABS( sic_bkginc(:,:) ) < ppsmall ) sic_bkginc(:,:) = 0.0_wp

#if defined key_si3 && defined key_asminc
            IF (lwp) THEN
               WRITE(numout,*)
               WRITE(numout,*) 'asm_inc_init : Converting single category increment to multi-category'
               WRITE(numout,*) '~~~~~~~~~~~~'
            END IF

            !single category increment for sea ice conc
            !convert single category increment to multi category
            at_i = SUM( a_i(:,:,:), DIM=3 )

            ! ensure rn_zhi_damin lies within 1st category
            IF ( rn_zhi_damin > hi_max(1) ) THEN
               IF (lwp) THEN
                  WRITE(numout,*)
                  WRITE(numout,*) 'minimum DA thickness > hmax(1): setting minimum DA thickness to hmax(1)'
                  WRITE(numout,*) '~~~~~~~~~~~~'
               END IF
               rn_zhi_damin = hi_max(1) - ppepsi02
            END IF

            DO jj = 1, jpj
               DO ji = 1, jpi
                  IF ( sic_bkginc(ji,jj) > 0.0_wp ) THEN
                     !positive ice concentration increments are always
                     !added to the thinnest category of ice
                     a_i_bkginc(ji,jj,1) = sic_bkginc(ji,jj)
                  ELSE
                     !negative increments are first removed from the thinnest
                     !available category until it reaches zero concentration
                     !and then progressively removed from thicker categories

                     !NOTE: might consider the remote possibility that zremaining_increment
                     !left over is not zero, particulary if SI3 is being run
                     !as a single category
                     zremaining_increment = sic_bkginc(ji,jj)
                     DO jl = 1, jpl
                        ! assign as much increment as possible to current category
                        a_i_bkginc(ji,jj,jl) = -MIN( a_i(ji,jj,jl), -zremaining_increment )
                        ! update remaining amount of increment
                        zremaining_increment = zremaining_increment - a_i_bkginc(ji,jj,jl)
                     END DO
                  END IF
               END DO
            END DO
            ! find model points where DA new ice should be added to open water
            ! in any ice category
            DO jl = 1,jpl
               WHERE ( at_i(:,:) < ppepsi02 .AND. sic_bkginc(:,:) > 0.0_wp )
                  lincr_newice(:,:,jl) = .TRUE.
               END WHERE
            END DO
#endif
         ENDIF
         !
         CALL iom_close( inum )
         !
      ENDIF
      !
      !                                            !--------------------------------------
      IF ( ln_dyninc .AND. nn_divdmp > 0 ) THEN    ! Apply divergence damping filter
         !                                         !--------------------------------------
         ALLOCATE( zhdiv(jpi,jpj) )
         !
         DO jt = 1, nn_divdmp
            !
            DO jk = 1, jpkm1           ! zhdiv = e1e1 * div
               zhdiv(:,:) = 0._wp
               DO_2D( 0, 0, 0, 0 )
                  zhdiv(ji,jj) = (  e2u(ji  ,jj) * e3u(ji  ,jj,jk,Kmm) * u_bkginc(ji  ,jj,jk)    &
                     &            - e2u(ji-1,jj) * e3u(ji-1,jj,jk,Kmm) * u_bkginc(ji-1,jj,jk)    &
                     &            + e1v(ji,jj  ) * e3v(ji,jj  ,jk,Kmm) * v_bkginc(ji,jj  ,jk)    &
                     &            - e1v(ji,jj-1) * e3v(ji,jj-1,jk,Kmm) * v_bkginc(ji,jj-1,jk)  ) &
                     &            / e3t(ji,jj,jk,Kmm)
               END_2D
               CALL lbc_lnk( 'asminc', zhdiv, 'T', 1.0_wp )   ! lateral boundary cond. (no sign change)
               !
               DO_2D( 0, 0, 0, 0 )
                  u_bkginc(ji,jj,jk) = u_bkginc(ji,jj,jk)                         &
                     &               + 0.2_wp * ( zhdiv(ji+1,jj) - zhdiv(ji  ,jj) ) * r1_e1u(ji,jj) * umask(ji,jj,jk)
                  v_bkginc(ji,jj,jk) = v_bkginc(ji,jj,jk)                         &
                     &               + 0.2_wp * ( zhdiv(ji,jj+1) - zhdiv(ji,jj  ) ) * r1_e2v(ji,jj) * vmask(ji,jj,jk)
               END_2D
            END DO
            !
         END DO
         !
         DEALLOCATE( zhdiv )
         !
      ENDIF
      !
      !                             !-----------------------------------------------------
      IF ( ln_asmdin ) THEN         ! Allocate and initialize the background state arrays
         !                          !-----------------------------------------------------
         !
         ALLOCATE( t_bkg  (jpi,jpj,jpk) )   ;   t_bkg  (:,:,:) = 0._wp
         ALLOCATE( s_bkg  (jpi,jpj,jpk) )   ;   s_bkg  (:,:,:) = 0._wp
         ALLOCATE( u_bkg  (jpi,jpj,jpk) )   ;   u_bkg  (:,:,:) = 0._wp
         ALLOCATE( v_bkg  (jpi,jpj,jpk) )   ;   v_bkg  (:,:,:) = 0._wp
         ALLOCATE( ssh_bkg(jpi,jpj)     )   ;   ssh_bkg(:,:)   = 0._wp
         !
         !
         !--------------------------------------------------------------------
         ! Read from file the background state at analysis time
         !--------------------------------------------------------------------
         !
         CALL iom_open( c_asmdin, inum )
         !
         CALL iom_get( inum, 'rdastp', zdate_bkg )
         !
         IF(lwp) THEN
            WRITE(numout,*)
            WRITE(numout,*) '   ==>>>  Assimilation background state valid at : ', zdate_bkg
            WRITE(numout,*)
         ENDIF
         !
         IF ( zdate_bkg /= dlditdin_date )   &
            & CALL ctl_warn( ' Validity time of assimilation background state does', &
            &                ' not agree with Direct Initialization time' )
         !
         IF ( ln_trainc ) THEN
            CALL iom_get( inum, jpdom_auto, 'tn', t_bkg )
            CALL iom_get( inum, jpdom_auto, 'sn', s_bkg )
            t_bkg(:,:,:) = t_bkg(:,:,:) * tmask(:,:,:)
            s_bkg(:,:,:) = s_bkg(:,:,:) * tmask(:,:,:)
         ENDIF
         !
         IF ( ln_dyninc ) THEN
            CALL iom_get( inum, jpdom_auto, 'un', u_bkg, cd_type = 'U', psgn = -1._wp )
            CALL iom_get( inum, jpdom_auto, 'vn', v_bkg, cd_type = 'V', psgn = -1._wp )
            u_bkg(:,:,:) = u_bkg(:,:,:) * umask(:,:,:)
            v_bkg(:,:,:) = v_bkg(:,:,:) * vmask(:,:,:)
         ENDIF
         !
         IF ( ln_sshinc ) THEN
            CALL iom_get( inum, jpdom_auto, 'sshn', ssh_bkg )
            ssh_bkg(:,:) = ssh_bkg(:,:) * tmask(:,:,1)
         ENDIF
         !
         CALL iom_close( inum )
         !
      ENDIF
      !
      IF(lwp) WRITE(numout,*) '   ==>>>   Euler time step switch is ', l_1st_euler
      !
      IF( lk_asminc ) THEN                            !==  data assimilation  ==!
         IF( ln_bkgwri )   CALL asm_bkg_wri( nit000 - 1, Kmm )      ! Output background fields
         IF( ln_asmdin ) THEN                                  ! Direct initialization
            IF( ln_trainc )   CALL tra_asm_inc( nit000 - 1, Kbb, Kmm, ts    , Krhs )      ! Tracers
            IF( ln_dyninc )   CALL dyn_asm_inc( nit000 - 1, Kbb, Kmm, uu, vv, Krhs )      ! Dynamics
            IF( ln_sshinc )   CALL ssh_asm_inc( nit000 - 1, Kbb, Kmm )                    ! SSH
         ENDIF
      ENDIF
      !
   END SUBROUTINE asm_inc_init


   SUBROUTINE tra_asm_inc( kt, Kbb, Kmm, pts, Krhs )
      !!----------------------------------------------------------------------
      !!                    ***  ROUTINE tra_asm_inc  ***
      !!
      !! ** Purpose : Apply the tracer (T and S) assimilation increments
      !!
      !! ** Method  : Direct initialization or Incremental Analysis Updating
      !!
      !! ** Action  :
      !!----------------------------------------------------------------------
      INTEGER                                  , INTENT(in   ) :: kt             ! Current time step
      INTEGER                                  , INTENT(in   ) :: Kbb, Kmm, Krhs ! Time level indices
      REAL(wp), DIMENSION(jpi,jpj,jpk,jpts,jpt), INTENT(inout) :: pts            ! active tracers and RHS of tracer equation
      !
      INTEGER  :: ji, jj, jk
      INTEGER  :: it
      REAL(wp) :: zincwgt  ! IAU weight for current time step
      REAL(wp), DIMENSION(:,:), ALLOCATABLE ::   zfzptnz, zdep2d   ! Freezing point values
      REAL(wp), DIMENSION(jpi,jpj,jpk)      ::   zvalid_bv         ! Mask representing Brunt-Vaisala (N2) checks used to reject T/S
                                                                   ! increments
      !!----------------------------------------------------------------------
         !                             !--------------------------------------
      IF ( ln_asmiau ) THEN            ! Incremental Analysis Updating
         !                             !--------------------------------------
         !
         IF ( ( kt >= nitiaustr_r ).AND.( kt <= nitiaufin_r ) ) THEN
            !
            it = kt - nit000 + 1
            zincwgt = wgtiau(it) / rn_Dt   ! IAU weight for the current time step
            !
            IF( .NOT. l_istiled .OR. ntile == 1 )  THEN                       ! Do only on the first tile
               IF(lwp) THEN
                  WRITE(numout,*)
                  WRITE(numout,*) 'tra_asm_inc : Tracer IAU at time step = ', kt,' with IAU weight = ', wgtiau(it)
                  WRITE(numout,*) '~~~~~~~~~~~~'
               ENDIF
            ENDIF
            !
            IF( ln_temnofreeze ) ALLOCATE( zfzptnz(T2D(0)), zdep2d(T2D(0)) )
            !
            ! Call Brunt-Vaisala checks to reject T/S increments
            zvalid_bv(:,:,:) = 1.0_wp
            IF ( ln_bv_check ) CALL verify_incs_bv( wgtiau(it), Kmm, pts, zvalid_bv )
            !
            ! Update the tracer tendencies
            DO jk = 1, jpkm1
               IF (ln_temnofreeze) THEN
                  ! Do not apply negative increments if the temperature will fall below freezing
                  DO_2D( 0, 0, 0, 0 )
                     zdep2d(ji,jj) = gdept(ji,jj,jk,Kmm)   ! better solution: define an interface for eos_fzp when gdept(ji,jj,jk,Kmm) is a scalar
                  END_2D
                  CALL eos_fzp( pts(:,:,jk,jp_sal,Kmm), zfzptnz(:,:), zdep2d(:,:), kbnd=0 )
                  !
                  WHERE(t_bkginc(T2D(0),jk) > 0.0_wp .OR. &
                     &   pts(T2D(0),jk,jp_tem,Kmm) + pts(T2D(0),jk,jp_tem,Krhs) + t_bkginc(T2D(0),jk) * wgtiau(it) > zfzptnz(:,:) )
                     pts(T2D(0),jk,jp_tem,Krhs) = pts(T2D(0),jk,jp_tem,Krhs) + t_bkginc(T2D(0),jk) * zvalid_bv(ji,jj,jk) * zincwgt
                  END WHERE
               ELSE
                  DO_2D( 0, 0, 0, 0 )
                     pts(ji,jj,jk,jp_tem,Krhs) = pts(ji,jj,jk,jp_tem,Krhs) + t_bkginc(ji,jj,jk) * zvalid_bv(ji,jj,jk) * zincwgt
                  END_2D
               ENDIF
               IF (ln_salfix) THEN
                  ! Do not apply negative increments if the salinity will fall below a specified
                  ! minimum value rn_salfixmin
                  WHERE(s_bkginc(T2D(0),jk) > 0.0_wp .OR. &
                     &   pts(T2D(0),jk,jp_sal,Kmm) + pts(T2D(0),jk,jp_sal,Krhs) + s_bkginc(T2D(0),jk) * wgtiau(it) > rn_salfixmin )
                     pts(T2D(0),jk,jp_sal,Krhs) = pts(T2D(0),jk,jp_sal,Krhs) + s_bkginc(T2D(0),jk) * zvalid_bv(ji,jj,jk) * zincwgt
                  END WHERE
               ELSE
                  DO_2D( 0, 0, 0, 0 )
                     pts(ji,jj,jk,jp_sal,Krhs) = pts(ji,jj,jk,jp_sal,Krhs) + s_bkginc(ji,jj,jk) * zvalid_bv(ji,jj,jk) * zincwgt
                  END_2D
               ENDIF
            END DO
            !
            IF( ln_temnofreeze ) DEALLOCATE( zfzptnz, zdep2d )
            !
         ENDIF
         !
         IF( .NOT. l_istiled .OR. ntile == nijtile )  THEN                ! Do only on the last tile
            IF ( kt == nitiaufin_r + 1  ) THEN   ! For bias crcn to work
               DEALLOCATE( t_bkginc )
               DEALLOCATE( s_bkginc )
            ENDIF
         ENDIF
         !                             !--------------------------------------
      ELSEIF ( ln_asmdin ) THEN        ! Direct Initialization
         !                             !--------------------------------------
         !
         IF ( kt == nitdin_r ) THEN
            !
            l_1st_euler = .TRUE.  ! Force Euler forward step
            !
            ! Call Brunt-Vaisala checks to reject T/S increments
            zvalid_bv(:,:,:) = 1.0_wp
            IF ( ln_bv_check ) CALL verify_incs_bv( 1.0_wp, Kmm, pts, zvalid_bv )
            !
            ! Initialize the now fields with the background + increment
            IF (ln_temnofreeze) THEN
               ! Do not apply negative increments if the temperature will fall below freezing
               ALLOCATE( zfzptnz(T2D(nn_hls)), zdep2d(T2D(nn_hls)) )
               !
               DO jk = 1, jpkm1
                  DO_2D( nn_hls, nn_hls, nn_hls, nn_hls )
                     zdep2d(ji,jj) = gdept(ji,jj,jk,Kmm)   ! better solution: define an interface for eos_fzp when gdept(ji,jj,jk,Kmm) is a scalar
                  END_2D
                  CALL eos_fzp( pts(:,:,jk,jp_sal,Kmm), zfzptnz(:,:), zdep2d(:,:) )
                  !
                  WHERE( t_bkginc(:,:,jk) > 0.0_wp .OR. pts(:,:,jk,jp_tem,Kmm) + t_bkginc(:,:,jk) > zfzptnz(:,:) )
                     pts(:,:,jk,jp_tem,Kmm) = t_bkg(:,:,jk) + t_bkginc(:,:,jk) * zvalid_bv(:,:,jk)
                  END WHERE
               END DO
               !
               DEALLOCATE( zfzptnz, zdep2d )
            ELSE
               pts(:,:,:,jp_tem,Kmm) = t_bkg(:,:,:) + t_bkginc(:,:,:) * zvalid_bv(:,:,:)
            ENDIF
            IF (ln_salfix) THEN
               ! Do not apply negative increments if the salinity will fall below a specified
               ! minimum value rn_salfixmin
               WHERE( s_bkginc(:,:,:) > 0.0_wp .OR. pts(:,:,:,jp_sal,Kmm) + s_bkginc(:,:,:) > rn_salfixmin )
                  pts(:,:,:,jp_sal,Kmm) = s_bkg(:,:,:) + s_bkginc(:,:,:) * zvalid_bv(:,:,:)
               END WHERE
            ELSE
               pts(:,:,:,jp_sal,Kmm) = s_bkg(:,:,:) + s_bkginc(:,:,:) * zvalid_bv(:,:,:)
            ENDIF

            pts(:,:,:,:,Kbb) = pts(:,:,:,:,Kmm)                 ! Update before fields
            CALL eos( pts, Kbb, rhd, rhop )                     ! Before potential and in situ densities

            DEALLOCATE( t_bkginc )
            DEALLOCATE( s_bkginc )
            DEALLOCATE( t_bkg    )
            DEALLOCATE( s_bkg    )
         ENDIF
         !
      ENDIF
      ! Perhaps the following call should be in step
      IF ( ln_sicinc )   CALL sic_asm_inc ( kt )      ! apply sea ice concentration increment
      IF ( ln_sitinc )   CALL sit_asm_inc ( kt )      ! apply sea ice thickness increment
      !
   END SUBROUTINE tra_asm_inc


   SUBROUTINE dyn_asm_inc( kt, Kbb, Kmm, puu, pvv, Krhs )
      !!----------------------------------------------------------------------
      !!                    ***  ROUTINE dyn_asm_inc  ***
      !!
      !! ** Purpose : Apply the dynamics (u and v) assimilation increments.
      !!
      !! ** Method  : Direct initialization or Incremental Analysis Updating.
      !!
      !! ** Action  :
      !!----------------------------------------------------------------------
      INTEGER                             , INTENT( in )  ::  kt             ! ocean time-step index
      INTEGER                             , INTENT( in )  ::  Kbb, Kmm, Krhs ! ocean time level indices
      REAL(wp), DIMENSION(jpi,jpj,jpk,jpt), INTENT(inout) ::  puu, pvv       ! ocean velocities and RHS of momentum equation
      !
      INTEGER :: ji, jj, jk
      INTEGER :: it
      REAL(wp) :: zincwgt  ! IAU weight for current time step
      !!----------------------------------------------------------------------
      !
      !                          !--------------------------------------------
      IF ( ln_asmiau ) THEN      ! Incremental Analysis Updating
         !                       !--------------------------------------------
         !
         IF ( ( kt >= nitiaustr_r ).AND.( kt <= nitiaufin_r ) ) THEN
            !
            it = kt - nit000 + 1
            zincwgt = wgtiau(it) / rn_Dt   ! IAU weight for the current time step
            !
            IF( .NOT. l_istiled .OR. ntile == 1 )  THEN                       ! Do only on the first tile
               IF(lwp) THEN
                  WRITE(numout,*)
                  WRITE(numout,*) 'dyn_asm_inc : Dynamics IAU at time step = ', kt,' with IAU weight = ', wgtiau(it)
                  WRITE(numout,*) '~~~~~~~~~~~~'
               ENDIF
            ENDIF
            !
            ! Update the dynamic tendencies
            DO_3D( 0, 0, 0, 0, 1, jpkm1 )
               puu(ji,jj,jk,Krhs) = puu(ji,jj,jk,Krhs) + u_bkginc(ji,jj,jk) * zincwgt
               pvv(ji,jj,jk,Krhs) = pvv(ji,jj,jk,Krhs) + v_bkginc(ji,jj,jk) * zincwgt
            END_3D
            !
            IF( .NOT. l_istiled .OR. ntile == nijtile )  THEN                ! Do only on the last tile
               IF ( kt == nitiaufin_r ) THEN
                  DEALLOCATE( u_bkginc )
                  DEALLOCATE( v_bkginc )
               ENDIF
            ENDIF
            !
         ENDIF
         !                          !-----------------------------------------
      ELSEIF ( ln_asmdin ) THEN     ! Direct Initialization
         !                          !-----------------------------------------
         !
         IF ( kt == nitdin_r ) THEN
            !
            l_1st_euler = .TRUE.                    ! Force Euler forward step
            !
            ! Initialize the now fields with the background + increment
            puu(:,:,:,Kmm) = u_bkg(:,:,:) + u_bkginc(:,:,:)
            pvv(:,:,:,Kmm) = v_bkg(:,:,:) + v_bkginc(:,:,:)
            !
            puu(:,:,:,Kbb) = puu(:,:,:,Kmm)         ! Update before fields
            pvv(:,:,:,Kbb) = pvv(:,:,:,Kmm)
            !
            DEALLOCATE( u_bkg    )
            DEALLOCATE( v_bkg    )
            DEALLOCATE( u_bkginc )
            DEALLOCATE( v_bkginc )
         ENDIF
         !
      ENDIF
      !
   END SUBROUTINE dyn_asm_inc


   SUBROUTINE ssh_asm_inc( kt, Kbb, Kmm )
      !!----------------------------------------------------------------------
      !!                    ***  ROUTINE ssh_asm_inc  ***
      !!
      !! ** Purpose : Apply the sea surface height assimilation increment.
      !!
      !! ** Method  : Direct initialization or Incremental Analysis Updating.
      !!
      !! ** Action  :
      !!----------------------------------------------------------------------
      INTEGER, INTENT(IN) :: kt         ! Current time step
      INTEGER, INTENT(IN) :: Kbb, Kmm   ! Current time step
      !
      INTEGER :: it
      INTEGER :: ji, jj, jk
      REAL(wp) :: zincwgt  ! IAU weight for current time step
      !!----------------------------------------------------------------------
      !
      !                             !-----------------------------------------
      IF ( ln_asmiau ) THEN         ! Incremental Analysis Updating
         !                          !-----------------------------------------
         !
         IF ( ( kt >= nitiaustr_r ).AND.( kt <= nitiaufin_r ) ) THEN
            !
            it = kt - nit000 + 1
            zincwgt = wgtiau(it) / rn_Dt   ! IAU weight for the current time step
            !
            IF( .NOT. l_istiled .OR. ntile == 1 )  THEN                       ! Do only on the first tile
               IF(lwp) THEN
                  WRITE(numout,*)
                  WRITE(numout,*) 'ssh_asm_inc : SSH IAU at time step = ', &
                     &  kt,' with IAU weight = ', wgtiau(it)
                  WRITE(numout,*) '~~~~~~~~~~~~'
               ENDIF
            ENDIF
            !
            ! Save the tendency associated with the IAU weighted SSH increment
            ! (applied in dynspg.*)
#if defined key_asminc
            DO_2D( nn_hls, nn_hls, nn_hls, nn_hls )
               ssh_iau(ji,jj) = ssh_bkginc(ji,jj) * zincwgt
            END_2D
#endif
            !
         ELSE IF( kt == nitiaufin_r+1 ) THEN
            !
            ! test on ssh_bkginc needed as ssh_asm_inc is called twice by time step
            IF( .NOT. l_istiled .OR. ntile == nijtile )  THEN                ! Do only on the last tile
               IF (ALLOCATED(ssh_bkginc)) DEALLOCATE( ssh_bkginc )
            ENDIF
            !
#if defined key_asminc
            DO_2D( nn_hls, nn_hls, nn_hls, nn_hls )
               ssh_iau(ji,jj) = 0._wp
            END_2D
#endif
            !
         ENDIF
         !                          !-----------------------------------------
      ELSEIF ( ln_asmdin ) THEN     ! Direct Initialization
         !                          !-----------------------------------------
         !
         IF ( kt == nitdin_r ) THEN
            !
            l_1st_euler = .TRUE.                            ! Force Euler forward step
            !
            ssh(:,:,Kmm) = ssh_bkg(:,:) + ssh_bkginc(:,:)   ! Initialize the now fields the background + increment
            !
            ssh(:,:,Kbb) = ssh(:,:,Kmm)                        ! Update before fields
#if ! defined key_qco && ! defined key_linssh
            e3t(:,:,:,Kbb) = e3t(:,:,:,Kmm)
#endif
!!gm why not e3u(:,:,:,Kbb), e3v(:,:,:,Kbb), gdept(:,:,:,Kbb) ????
            !
            DEALLOCATE( ssh_bkg    )
            DEALLOCATE( ssh_bkginc )
            !
         ENDIF
         !
      ENDIF
      !
   END SUBROUTINE ssh_asm_inc


   SUBROUTINE ssh_asm_div( kt, Kbb, Kmm, phdivn )
      !!----------------------------------------------------------------------
      !!                  ***  ROUTINE ssh_asm_div  ***
      !!
      !! ** Purpose :   ssh increment with z* is incorporated via a correction of the local divergence
      !!                across all the water column
      !!
      !! ** Method  :
      !!                CAUTION : sshiau is positive (inflow) decreasing the
      !!                          divergence and expressed in m/s
      !!
      !! ** Action  :   phdivn   decreased by the ssh increment
      !!----------------------------------------------------------------------
      INTEGER, INTENT(IN) :: kt                                    ! ocean time-step index
      INTEGER, INTENT(IN) :: Kbb, Kmm                              ! time level indices
      REAL(wp), DIMENSION(A2D(1),jpk), INTENT(inout) ::   phdivn   ! horizontal divergence
      !!
      INTEGER  ::   ji, jj, jk   ! dummy loop index
      REAL(wp) ::   ztim         ! local scalar
      !!----------------------------------------------------------------------
      !
#if defined key_asminc
      CALL ssh_asm_inc( kt, Kbb, Kmm ) !==   (calculate increments)
      !
      IF( lk_linssh ) THEN
         DO_2D( 1, 1, 1, 1 )
            phdivn(ji,jj,1) = phdivn(ji,jj,1) - ssh_iau(ji,jj) / e3t(ji,jj,1,Kmm) * tmask(ji,jj,1)
         END_2D
      ELSE
         DO_2D( 1, 1, 1, 1 )
            ztim = ssh_iau(ji,jj) / ( ht(ji,jj,Kmm) + 1.0 - ssmask(ji,jj) )
            DO jk = 1, jpkm1
               phdivn(ji,jj,jk) = phdivn(ji,jj,jk) - ztim * tmask(ji,jj,jk)
            END DO
         END_2D
      ENDIF
#endif
      !
   END SUBROUTINE ssh_asm_div


   SUBROUTINE sic_asm_inc( kt, kindic )
      !!----------------------------------------------------------------------
      !!                    ***  ROUTINE sic_asm_inc  ***
      !!
      !! ** Purpose : Apply the sea ice concentration assimilation increment.
      !!
      !! ** Method  : Direct initialization or Incremental Analysis Updating.
      !!
      !! ** Action  :
      !!
      !!----------------------------------------------------------------------
      INTEGER, INTENT(in)           ::   kt       ! Current time step
      INTEGER, INTENT(in), OPTIONAL ::   kindic   ! flag for disabling the deallocation
      !
      INTEGER  ::   it, jk
      REAL(wp) ::   zincwgt                            ! IAU weight for current time step
#if defined key_si3 && defined key_asminc
      REAL(wp), DIMENSION(jpi,jpj,jpl) :: zda_i        ! change in ice concentration
      REAL(wp), DIMENSION(jpi,jpj,jpl) :: zdv_i        ! change in ice volume
      REAL(wp), DIMENSION(jpi,jpj,jpl) :: z1_a_i       ! inverse of ice concentration before current IAU step
      REAL(wp), DIMENSION(jpi,jpj,jpl) :: z1_v_i       ! inverse of ice volume before current IAU step
      REAL(wp), DIMENSION(jpi,jpj)     :: zhi_damin_2D ! array with DA thickness for lincr_newice
#endif
      !!----------------------------------------------------------------------
      !
      !                             !-----------------------------------------
      IF ( ln_asmiau ) THEN         ! Incremental Analysis Updating
         !                          !-----------------------------------------
         !
         IF ( ( kt >= nitiaustr_r ).AND.( kt <= nitiaufin_r ) ) THEN
            !
            it = kt - nit000 + 1
            zincwgt = wgtiau(it)      ! IAU weight for the current time step
            ! note this is not a tendency so should not be divided by rdt (as with the tracer and other increments)
            !
            IF(lwp) THEN
               WRITE(numout,*)
               WRITE(numout,*) 'sic_asm_inc : sea ice conc IAU at time step = ', kt,' with IAU weight = ', wgtiau(it)
               WRITE(numout,*) '~~~~~~~~~~~~'
            ENDIF
            !
            ! Sea-ice : SI3 case
            !
#if defined key_si3 && defined key_asminc
            ! compute the inverse of key sea ice variables
            ! to be used later in the code
            WHERE( a_i(:,:,:) > epsi10 )
               z1_a_i(:,:,:) = 1.0_wp / a_i(:,:,:)
               z1_v_i(:,:,:) = 1.0_wp / v_i(:,:,:)
            ELSEWHERE
               z1_a_i(:,:,:) = 0.0_wp
               z1_v_i(:,:,:) = 0.0_wp
            END WHERE

            ! add positive concentration increments to regions where ice
            ! is already present and bound them to 1
            ! ice volume is added based on rn_zhi_damin
            WHERE ( .NOT. lincr_newice .AND. a_i_bkginc(:,:,:) > 0.0_wp )
               a_i(:,:,:) = a_i(:,:,:) + MIN( 1.0_wp - a_i(:,:,:), a_i_bkginc(:,:,:) * zincwgt )
               v_i(:,:,:) = v_i(:,:,:) + MIN( 1.0_wp - a_i(:,:,:), a_i_bkginc(:,:,:) * zincwgt ) * rn_zhi_damin
            END WHERE

            ! add negative concentration increments to regions where ice
            ! is already present and bound them to 0
            ! in this case ice volume is changed based on the current thickness
            WHERE ( .NOT. lincr_newice .AND. a_i_bkginc(:,:,:) < 0.0_wp )
               a_i(:,:,:) = MAX( a_i(:,:,:) + a_i_bkginc(:,:,:) * zincwgt, 0.0_wp )
               v_i(:,:,:) = a_i(:,:,:) * h_i(:,:,:)
            END WHERE

            ! compute changes in ice concentration and volume
            WHERE ( lincr_newice )
               zda_i(:,:,:) = 1.0_wp
               zdv_i(:,:,:) = 1.0_wp
            ELSEWHERE
               zda_i(:,:,:) = a_i(:,:,:) * z1_a_i(:,:,:)
               zdv_i(:,:,:) = v_i(:,:,:) * z1_v_i(:,:,:)
            END WHERE

            ! initialise thermodynamics of new ice being added to open water
            ! just do it once since next IAU steps assume that new ice has
            ! already been added in
            IF ( kt == nitiaustr_r ) THEN

               ! assign rn_zhi_damin to ice forming in open water
               WHERE ( ANY( lincr_newice, DIM=3 ) )
                  zhi_damin_2D(:,:) = rn_zhi_damin
               ELSEWHERE
                  zhi_damin_2D(:,:) = 0.0_wp
               END WHERE

               ! add ice concentration and volume
               ! ensure the other prognostic variables are set to zero
               WHERE ( lincr_newice )
                  a_i(:,:,:) = MIN( 1.0_wp, a_i_bkginc(:,:,:) * zincwgt )
                  v_i(:,:,:) = MIN( 1.0_wp, a_i_bkginc(:,:,:) * zincwgt ) * rn_zhi_damin
                  v_s (:,:,:) = 0.0_wp
                  a_ip(:,:,:) = 0.0_wp
                  v_ip(:,:,:) = 0.0_wp
                  sv_i(:,:,:) = 0.0_wp
               END WHERE
               DO jk = 1, nlay_i
                  WHERE ( lincr_newice )
                     e_i(:,:,jk,:) = 0.0_wp
                  END WHERE
               END DO
               DO jk = 1, nlay_s
                  WHERE ( lincr_newice )
                     e_s(:,:,jk,:) = 0.0_wp
                  END WHERE
               END DO

               ! Initialisation of the salt content and ice enthalpy
               ! set flag of new ice to false after this
               CALL init_new_ice_thd( zhi_damin_2D )
               lincr_newice(:,:,:) = .FALSE.
            END IF

            ! maintain equivalent values for key prognostic variables
            v_s(:,:,:) = v_s(:,:,:) * zda_i(:,:,:)
            DO jk = 1, nlay_s
               e_s(:,:,jk,:) = e_s(:,:,jk,:) * zda_i(:,:,:)
            END DO
            a_ip (:,:,:) = a_ip(:,:,:) * zda_i(:,:,:)
            v_ip (:,:,:) = v_ip(:,:,:) * zda_i(:,:,:)

            ! ice volume dependent variables
            DO jk = 1, nlay_i
               e_i(:,:,jk,:) = e_i(:,:,jk,:) * zdv_i(:,:,:)
            END DO
#endif

#if defined key_cice && defined key_asminc
            ! Sea-ice : CICE case. Pass ice increment tendency into CICE
            ndaice_da(:,:) = sic_bkginc(:,:) * zincwgt / rdt
#endif
            !
            IF ( kt == nitiaufin_r ) THEN
               DEALLOCATE( sic_bkginc )
#if defined key_si3 && defined key_asminc
               DEALLOCATE( lincr_newice )
               DEALLOCATE( a_i_bkginc )
#endif
            ENDIF
            !
         ELSE
            !
#if defined key_cice && defined key_asminc
            ndaice_da(:,:) = 0._wp        ! Sea-ice : CICE case. Zero ice increment tendency into CICE
#endif
            !
         ENDIF
         !                          !-----------------------------------------
      ELSEIF ( ln_asmdin ) THEN     ! Direct Initialization
         !                          !-----------------------------------------
         !
         IF ( kt == nitdin_r ) THEN
            !
            l_1st_euler = .TRUE.                    ! Force Euler forward step

            IF(lwp) THEN
               WRITE(numout,*)
               WRITE(numout,*) 'sic_asm_inc : sea ice direct initialization at time step = ', kt
               WRITE(numout,*) '~~~~~~~~~~~~'
            ENDIF
            !
#if defined key_cice && defined key_asminc
            ! Sea-ice : CICE case. Pass ice increment tendency into CICE
           ndaice_da(:,:) = sic_bkginc(:,:) / rdt
#endif
            IF ( .NOT. PRESENT(kindic) ) THEN
               DEALLOCATE( sic_bkginc )
            END IF
            !
         ELSE
            !
#if defined key_cice && defined key_asminc
            ndaice_da(:,:) = 0._wp     ! Sea-ice : CICE case. Zero ice increment tendency into CICE
#endif
            !
         ENDIF
         !
      ENDIF
      !
   END SUBROUTINE sic_asm_inc


   SUBROUTINE sit_asm_inc( kt, kindic )
      !!----------------------------------------------------------------------
      !!                    ***  ROUTINE sit_asm_inc  ***
      !!
      !! ** Purpose : Apply the sea ice thickness assimilation increment.
      !!
      !! ** Method  : Direct initialization or Incremental Analysis Updating.
      !!
      !! ** Action  :
      !!
      !!----------------------------------------------------------------------
      INTEGER, INTENT(in)           ::   kt       ! Current time step
      INTEGER, INTENT(in), OPTIONAL ::   kindic   ! flag for disabling the deallocation
      !
      INTEGER  ::   it, jl
      REAL(wp) ::   zincwgt                            ! IAU weight for current time step
      !!----------------------------------------------------------------------
      !
      !                             !-----------------------------------------
      IF ( ln_asmiau ) THEN         ! Incremental Analysis Updating
         !                          !-----------------------------------------
         !
         IF ( ( kt >= nitiaustr_r ).AND.( kt <= nitiaufin_r ) ) THEN
            !
            it = kt - nit000 + 1
            zincwgt = wgtiau(it)      ! IAU weight for the current time step
            ! note this is not a tendency so should not be divided by rdt (as with the tracer and other increments)
            !
            IF(lwp) THEN
               WRITE(numout,*)
               WRITE(numout,*) 'sit_asm_inc : sea ice thickness IAU at time step = ', kt,' with IAU weight = ', wgtiau(it)
               WRITE(numout,*) '~~~~~~~~~~~~'
            ENDIF
            !
#if defined key_si3 && defined key_asminc
            ! Sea-ice thickess: SI3 case
            at_i = SUM( a_i(:,:,:), DIM=3 )
            vt_i = SUM( v_i(:,:,:), DIM=3 )

            ! Apply Grid-Box Mean (GBM) thickness increments where total ice concentration
            ! is greater than minimum concentration required (rn_ai_damin)
            ! This is done by calculating the initial volume fraction in each category and
            ! then adding that fraction of GBM thickness increments to each category if
            ! its ice concentration is greater than rn_acat_damin
            DO jl = 1, jpl
               WHERE( ABS( sit_bkginc(:,:) ) > epsi10 .AND. at_i(:,:) > rn_ai_damin .AND. a_i(:,:,jl) > rn_acat_damin )
                   v_i(:,:,jl) = v_i(:,:,jl) + ( sit_bkginc(:,:) * zincwgt ) * v_i(:,:,jl) / vt_i(:,:)
               END WHERE
            END DO

            ! Making sure that there are no negative ice volumes after GBM thickness
            ! increments are applied
            WHERE( v_i(:,:,:) < 0.0_wp )
                v_i(:,:,:) = 0.0_wp
                a_i(:,:,:) = 0.0_wp
            END WHERE
#endif

#if defined key_cice && defined key_asminc
            ! Sea-ice thickness: CICE case. Pass ice increment tendency into CICE
            ndaice_da(:,:) = sit_bkginc(:,:) * zincwgt / rdt
#endif
            !
            IF ( kt == nitiaufin_r ) THEN
               DEALLOCATE( sit_bkginc )
            ENDIF
            !
         ELSE
            !
#if defined key_cice && defined key_asminc
            ndaice_da(:,:) = 0._wp        ! Sea-ice thickness: CICE case. Zero ice increment tendency into CICE
#endif
            !
         ENDIF
         !                          !-----------------------------------------
      ELSEIF ( ln_asmdin ) THEN     ! Direct Initialization
         !                          !-----------------------------------------
         !
         IF ( kt == nitdin_r ) THEN
            !
            l_1st_euler = .TRUE.                    ! Force Euler forward step

            IF(lwp) THEN
               WRITE(numout,*)
               WRITE(numout,*) 'sit_asm_inc : sea ice thickness direct initialization at time step = ', kt
               WRITE(numout,*) '~~~~~~~~~~~~'
            ENDIF
            !
#if defined key_si3 && defined key_asminc
            ! Sea-ice thickess: SI3 case
            at_i = SUM( a_i(:,:,:), DIM=3 )
            vt_i = SUM( v_i(:,:,:), DIM=3 )

            ! Apply Grid-Box Mean (GBM) thickness increments where total ice concentration
            ! is greater than minimum concentration required (rn_ai_damin)
            ! This is done by calculating the initial volume fraction in each category and
            ! then adding that fraction of GBM thickness increments to each category if
            ! its ice concentration is greater than rn_acat_damin
            DO jl = 1, jpl
               WHERE( ABS( sit_bkginc(:,:) ) > epsi10 .AND. at_i(:,:) > rn_ai_damin .AND. a_i(:,:,jl) > rn_acat_damin )
                   v_i(:,:,jl) = v_i(:,:,jl) + sit_bkginc(:,:) * v_i(:,:,jl) / vt_i(:,:)
               END WHERE
            END DO

            ! Making sure that there are no negative ice volumes after GBM thickness
            ! increments are applied
            WHERE( v_i(:,:,:) < 0.0_wp )
                v_i(:,:,:) = 0.0_wp
                a_i(:,:,:) = 0.0_wp
            END WHERE
#endif

#if defined key_cice && defined key_asminc
            ! Sea-ice thickness: CICE case. Pass ice increment tendency into CICE
            ndaice_da(:,:) = sit_bkginc(:,:) / rdt
#endif
            IF ( .NOT. PRESENT(kindic) ) THEN
               DEALLOCATE( sit_bkginc )
            END IF
            !
         ELSE
            !
#if defined key_cice && defined key_asminc
            ndaice_da(:,:) = 0._wp     ! Sea-ice thickness: CICE case. Zero ice increment tendency into CICE
#endif
            !
         ENDIF
         !
      ENDIF
      !
   END SUBROUTINE sit_asm_inc

#if defined key_si3 && defined key_asminc
   SUBROUTINE init_new_ice_thd( hi_new )
      !!----------------------------------------------------------------------
      !!                  ***  ROUTINE init_new_ice_thd  ***
      !!
      !! ** Purpose :   Initialise thermodynamics of new ice
      !!                forming at 1st category with thickness hi_new
      !!
      !! ** Method  :   Apply SI3  equations to initialise
      !!                thermodynamics of new ice
      !!
      !! ** Action  :   Update sea ice thermodynamics
      !!----------------------------------------------------------------------
      REAL(wp), DIMENSION(jpi,jpj), INTENT(in)    ::   hi_new  ! total thickness of new ice

      INTEGER             :: jj, ji, jk          ! loop variables
      REAL(wp)            :: ztmelts             ! melting point
      REAL(wp), PARAMETER :: ppSice_Fz = 2.3_wp  ! Salinity of the ice = F(z) [multiyear ice]

      REAL(wp), DIMENSION(jpij) ::   zs_newice   ! salinity of new ice
      !!----------------------------------------------------------------------

      ! Identify grid points where new ice forms
      npti = 0   ;   nptidx(:) = 0
      DO jj = 1, jpj
         DO ji = 1, jpi
            IF ( hi_new(ji,jj) > 0._wp ) THEN
               npti = npti + 1
               nptidx( npti ) = (jj - 1) * jpi + ji
            ENDIF
         END DO
      END DO

      ! Move from 2-D to 1-D vectors
      IF ( npti > 0 ) THEN
         CALL tab_3d_2d( npti, nptidx(1:npti), sv_i_2d(1:npti,1:jpl), sv_i(:,:,:) )
         CALL tab_3d_2d( npti, nptidx(1:npti), v_i_2d (1:npti,1:jpl), v_i (:,:,:) )
         CALL tab_2d_1d( npti, nptidx(1:npti), sss_1d    (1:npti) , sss_m         )
         CALL tab_2d_1d( npti, nptidx(1:npti), t_bo_1d   (1:npti) , t_bo          )
         DO jk = 1, nlay_i
            CALL tab_2d_1d( npti, nptidx(1:npti), e_i_1d(1:npti,jk), e_i(:,:,jk,1) )
         END DO

         ! --- Salinity of new ice --- !
         SELECT CASE ( nn_icesal )
         CASE ( 1 )                    ! Sice = constant
            zs_newice(1:npti) = rn_icesal
         CASE ( 2 , 4 )                ! Sice = F(z,t) [Griewank and Notz 2013 ; Rees Jones and Worster 2014]
            zs_newice(1:npti) = rn_sinew * sss_1d(1:npti)
         CASE ( 3 )                    ! Sice = F(z) [multiyear ice]
            zs_newice(1:npti) = ppSice_Fz
         END SELECT

         ! --- Update ice salt content --- !
         DO ji = 1, npti
            sv_i_2d(ji,1) = sv_i_2d(ji,1) + zs_newice(ji) * ( v_i_2d(ji,1) )
         END DO

         ! --- Heat content of new ice --- !
         ! We assume that new ice is formed at the seawater freezing point
         DO ji = 1, npti
               ztmelts       = - rTmlt * zs_newice(ji)                  ! Melting point (C)
               e_i_1d(ji,:)  =   rhoi * (  rcpi  * ( ztmelts - ( t_bo_1d(ji) - rt0 ) )                        &
                  &                      + rLfus * ( 1.0_wp - ztmelts / MIN( t_bo_1d(ji) - rt0, -epsi10 ) )   &
                  &                      - rcp   *         ztmelts )
         END DO

         ! Change units for e_i
         DO jk = 1, nlay_i
            e_i_1d(1:npti,jk) = e_i_1d(1:npti,jk) * v_i_2d(1:npti,1) * r1_nlay_i
         END DO

         ! Reforming full thermodynamic variables
         CALL tab_2d_3d( npti, nptidx(1:npti), sv_i_2d(1:npti,1:jpl), sv_i(:,:,:) )
         DO jk = 1, nlay_i
               CALL tab_1d_2d( npti, nptidx(1:npti), e_i_1d(1:npti,jk), e_i(:,:,jk,1) )
         END DO
      END IF

   END SUBROUTINE init_new_ice_thd
#endif

   SUBROUTINE verify_incs_bv( pwgt, Kmm, pts, punstab )
      !!----------------------------------------------------------------------
      !!                    ***  ROUTINE   ***
      !!
      !! ** Purpose : Map water column instabilities after applying increments
      !!
      !! ** Method  : Calculate Brunt-Vaisala N2 values
      !!
      !! ** Action  : Return mask where increments should not be applied
      !!
      !!----------------------------------------------------------------------
      !!
      !!
      !!----------------------------------------------------------------------
      IMPLICIT NONE
      !
      REAL(wp),                                  INTENT(IN)    :: pwgt       ! Weights applied to increments
      INTEGER,                                   INTENT(IN)    :: Kmm        ! Time level indices
      REAL(wp), DIMENSION(jpi,jpj,jpk,jpts,jpt), INTENT(IN)    :: pts        ! Active tracers and RHS of tracer equation
      REAL(wp), DIMENSION(jpi,jpj,jpk),          INTENT(INOUT) :: punstab    ! Flag grid points where water column is unstable (=0)
      REAL(wp), DIMENSION(jpi,jpj,jpk,jpts)                    ::   zntsn    ! T and S fields after applying increments
      REAL(wp), DIMENSION(jpi,jpj,jpk,jpts)                    :: zab        ! thermal/haline expansion ratio
      REAL(wp), DIMENSION(jpi,jpj,jpk)                         :: zn2        ! Brunt-Vaisala frequency squared (s^2)
      INTEGER                                                  :: jk, jj, ji ! Loop counters

      ! T/S after applying increments
      zntsn(:,:,:,jp_tem) = pts(:,:,:,jp_tem,Kmm) + t_bkginc(:,:,:) * pwgt
      zntsn(:,:,:,jp_sal) = pts(:,:,:,jp_sal,Kmm) + s_bkginc(:,:,:) * pwgt

      ! Get thermal/haline expansion ratio
      CALL eos_rab( zntsn, zab, Kmm )

      ! Compute Brunt-Vaisala frequency squared (given on W grid)
      CALL bn2( zntsn, zab, zn2, Kmm )

      jj_loop: DO jj = 1, jpj
         ji_loop: DO ji = 1, jpi
            jk_loop: DO jk = 1, jpk
               IF ( gdepw(ji,jj,jk,Kmm) >= rn_zmin_bv .AND. gdepw(ji,jj,jk,Kmm) <= rn_zmax_bv .AND. &
                 &  zn2(ji,jj,jk) < rn_bv_thres ) THEN
                  punstab(ji,jj,:) = 0.0_wp
                  EXIT jk_loop
               END IF
            END DO jk_loop
         END DO ji_loop
      END DO jj_loop

   END SUBROUTINE verify_incs_bv

   !!======================================================================
END MODULE asminc

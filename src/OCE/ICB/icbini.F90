MODULE icbini
   !!======================================================================
   !!                       ***  MODULE  icbini  ***
   !! Icebergs:  initialise variables for iceberg tracking
   !!======================================================================
   !! History :   -   !  2010-01  (T. Martin & A. Adcroft)  Original code
   !!            3.3  !  2011-03  (G. Madec)  Part conversion to NEMO form ; Removal of mapping from another grid
   !!             -   !  2011-04  (S. Alderson)  Split into separate modules ; Restore restart routines
   !!             -   !  2011-05  (S. Alderson)  generate_test_icebergs restored ; new forcing arrays with extra halo ;
   !!             -   !                          north fold exchange arrays added
   !!----------------------------------------------------------------------
   !!----------------------------------------------------------------------
   !!   icb_init     : initialise icebergs
   !!   icb_ini_gen  : generate test icebergs
   !!   icb_nam      : read iceberg namelist
   !!----------------------------------------------------------------------
   USE dom_oce        ! ocean domain
   USE in_out_manager ! IO routines and numout in particular
   USE lib_mpp        ! mpi library and lk_mpp in particular
   USE sbc_oce        ! ocean  : surface boundary condition
   USE sbc_ice        ! sea-ice: surface boundary condition
   USE iom            ! IOM library
   USE fldread        ! field read
   USE lbclnk         ! lateral boundary condition - MPP link
   !
   USE icb_oce        ! define iceberg arrays
   USE icbutl         ! iceberg utility routines
   USE icbrst         ! iceberg restart routines
   USE icbtrj         ! iceberg trajectory I/O routines
   USE icbdia         ! iceberg budget routines

   IMPLICIT NONE
   PRIVATE

   PUBLIC   icb_init  ! routine called in nemogcm.F90 module

   CHARACTER(len=100)                                 ::   cn_dir = './'   !: Root directory for location of icb files
   TYPE(FLD_N)                                        ::   sn_icb          !: information about the calving file to be read
   TYPE(FLD), PUBLIC, ALLOCATABLE     , DIMENSION(:)  ::   sf_icb          !: structure: file information, fields read
                                                                           !: used in icbini and icbstp
   !! * Substitutions
#  include "do_loop_substitute.h90"
#  include "read_nml_substitute.h90"
   !!----------------------------------------------------------------------
   !! NEMO/OCE 5.0, NEMO Consortium (2024)
   !! Software governed by the CeCILL license (see ./LICENSE)
   !!----------------------------------------------------------------------
CONTAINS

   SUBROUTINE icb_init( pdt, kt, Kmm )
      !!----------------------------------------------------------------------
      !!                  ***  ROUTINE dom_init  ***
      !!
      !! ** Purpose :   iceberg initialization.
      !!
      !! ** Method  : - read the iceberg namelist
      !!              - find non-overlapping processor interior since we can only
      !!                have one instance of a particular iceberg
      !!              - calculate the destinations for north fold exchanges
      !!              - setup either test icebergs or calving file
      !!----------------------------------------------------------------------
      REAL(wp), INTENT(in) ::   pdt   ! iceberg time-step (rn_Dt*nn_fsbc)
      INTEGER , INTENT(in) ::   kt    ! time step number
      INTEGER , INTENT(in) ::   Kmm   ! ocean time level index
      !
      INTEGER ::   ji, jj, jn               ! dummy loop indices
      INTEGER ::   i1, i2, i3               ! local integers
      INTEGER ::   ii, inum, ivar           !   -       -
      INTEGER ::   istat1, istat2, istat3   !   -       -
      CHARACTER(len=300) ::   cl_sdist      ! local character
      !!----------------------------------------------------------------------
      !
      CALL icb_nam               ! Read and print namelist parameters
      !
      IF( .NOT. ln_icebergs )   RETURN
      !
      ALLOCATE( utau_icb(jpi,jpj), vtau_icb(jpi,jpj) )
      !
      !                          ! allocate gridded fields
      IF( icb_alloc() /= 0 )   CALL ctl_stop( 'STOP', 'icb_alloc : unable to allocate arrays' )
      !
      !                          ! open ascii output file or files for iceberg status information
      !                          ! note that we choose to do this on all processors since we cannot
      !                          ! predict where icebergs will be ahead of time
      IF( nn_verbose_level > 0) THEN
         CALL ctl_opn( numicb, 'icebergs.stat', 'REPLACE', 'FORMATTED', 'SEQUENTIAL', -1, numout, lwp, narea )
      ENDIF

      ! set parameters (mostly from namelist)
      !
      berg_dt         = pdt
      first_width (:) = SQRT(  rn_initial_mass(:) / ( rn_LoW_ratio * rn_rho_bergs * rn_initial_thickness(:) )  )
      first_length(:) = rn_LoW_ratio * first_width(:)
      rho_berg_1_oce  = rn_rho_bergs / pp_rho_seawater  ! scale factor used for convertion thickness to draft
      !
      ! deepest level affected by icebergs
      ! can be tuned but the safest is this 
      ! (with z* and z~ the depth of each level change overtime, so the more robust micbkb is jpk)
      micbkb = jpk

      berg_grid%calving      (:,:)   = 0._wp
      berg_grid%calving_hflx (:,:)   = 0._wp
      berg_grid%stored_heat  (:,:)   = 0._wp
      berg_grid%floating_melt(:,:)   = 0._wp
      berg_grid%maxclass     (:,:)   = nclasses
      berg_grid%stored_ice   (:,:,:) = 0._wp
      berg_grid%tmp          (:,:)   = 0._wp
      src_calving            (:,:)   = 0._wp
      src_calving_hflx       (:,:)   = 0._wp

      !                          ! domain for icebergs
      ! for the north fold we work out which points communicate by asking
      ! lbc_lnk to pass processor number (valid even in single processor case)
      ! borrow src_calving arrays for this
      !
      ! pack i and j together using a scaling of a power of 10
      ! (PM) use 100000 because eORCA36 for example run on more than 10 000 processors
      nicbpack = 100000
      IF( (jpiglo >= nicbpack) .OR. (jpjglo*nicbpack+jpiglo > HUGE(src_calving)) )   CALL ctl_stop( 'icbini: processor index packing failure' )
      nicbfldproc(:) = -1
      ! src_calving and src_calving_hflx init : important for mpp exchanges and North fold
      ! src_calving contains a unique index for each point of the grid (that "gather" its global ji and jj in one number)
      DO_2D( 1, 1, 1, 1 )
         src_calving_hflx(ji,jj) = narea
         src_calving     (ji,jj) = nicbpack * mjg(jj,nn_hls) + mig(ji,nn_hls)
      END_2D
      
      CALL lbc_lnk( 'icbini', src_calving_hflx, 'T', 1._wp)
      CALL lbc_lnk( 'icbini', src_calving     , 'T', 1._wp)

      !ricb_left and right :  ji-local-destination index for east-west boundary exchange 

      ricb_left = REAL( MOD( INT( src_calving( MAX(Nis0-1,-1) , jpj/2 ) ), nicbpack ) ,wp) - (nn_hls - 1)  
      ricb_right = REAL( MOD( INT( src_calving( MIN(Nie0+1,jpi) , jpj/2 ) ), nicbpack ) ,wp) - (nn_hls - 1)

      ! north fold
      IF( l_IdoNFold ) THEN
         
         !! ---------------------------------------------------
         !! INITIALIZING ARRAYS FOR bergs through NORTH Fold 
         !! note that this init englobes both mpp and monoproc / jpni == 1 cases
         !!   
         !! nicbfldborder(ji = 1:jpi)  : global position of the nfold border inside the local subdomain of the proc 
         !! nicbfldpts(ji = 1:jpi)     : value of src_calving(ji,jj) at the destination points of the nfld (example : 1500003)
         !! nicbflddest(ji = 1:jpi)    : id number of the destination proc(s) of the nfld.

         !! IMPORTANT !! : the case where the T-pivot point for nfld is 
         !! inside the subdomain of a proc is dealt with. (typically jpni = 1 or jpni = 3)
         !! concretly,for such a proc, the values of nicbfldborder will be (149 149 .... 149 148 ... 148).
         !! the transition (149 to 148) is done from the first point to the right of the nfld pivot.

         ! see nemo manual section E.1. North Pole Folding around a T-Point     
         
         nicbfldborder(:) = -1

         DO ji = 1, jpi
           DO jj = 1, jpj
           
           ! src_calving has been called by lbc_lnk. Before that we had everywhere
           ! INT(src_calving) = mjg * nicbpack + mig  
           
           ! So, the following if-test is .false. for every point of the nfld halo
           
             IF( (mjg(jj,nn_hls) * nicbpack + mig(ji,nn_hls))   == INT( src_calving(ji,jj) )  ) THEN
                
                !! for each ji, jj increases until the first halo point is found 
                !! (either to the left or to the right of the Nfold pivot point ) 

                nicbfldborder(ji) = mjg(jj,nn_hls) - (nn_hls - 1)
                nicbfldpts(ji) = INT( src_calving(ji,jj+1) )
                nicbflddest(ji) = INT( src_calving_hflx(ji,jj+1) )

              ENDIF
            END DO ! Do jpj
         END DO ! Do jpi
        

         ! work out list of unique processors to talk to
         ! pack them into a fixed size array where empty slots are marked by a -1
         DO ji = Nis0, Nie0
            ii = nicbflddest(ji)
            IF( ii .GT. 0 ) THEN     ! Needed because land suppression can mean
                                     ! that unused points are not set in edge haloes
               DO jn = 1, jpni
                  ! work along array until we find an empty slot
                  IF( nicbfldproc(jn) == -1 ) THEN
                     nicbfldproc(jn) = ii
                     EXIT                             !!gm EXIT should be avoided: use DO WHILE expression instead
                  ENDIF
                  ! before we find an empty slot, we may find processor number is already here so we exit
                  IF( nicbfldproc(jn) == ii ) EXIT
               END DO
            ENDIF
         END DO
      ENDIF
      !
      IF( nn_verbose_level > 0) THEN
         WRITE(numicb,*) 'processor ', narea
         WRITE(numicb,*) 'jpi, jpj   ', jpi, jpj
         WRITE(numicb,*) 'Nis0, Nie0 ', Nis0, Nie0
         WRITE(numicb,*) 'Njs0, Nje0 ', Njs0, Nje0
         WRITE(numicb,*) 'berg left       ', ricb_left
         WRITE(numicb,*) 'berg right      ', ricb_right
         jj = jpj/2
         WRITE(numicb,*) "central j line:"
         WRITE(numicb,*) "i processor"
         WRITE(numicb,*) (INT(src_calving_hflx(ji,jj)), ji=1,jpi)
         WRITE(numicb,*) "i point"
         WRITE(numicb,*) (INT(src_calving(ji,jj)), ji=1,jpi)
         ji = jpi/2
         WRITE(numicb,*) "central i line:"
         WRITE(numicb,*) "j processor"
         WRITE(numicb,*) (INT(src_calving_hflx(ji,jj)), jj=1,jpj)
         WRITE(numicb,*) "j point"
         WRITE(numicb,*) (INT(src_calving(ji,jj)), jj=1,jpj)
         IF( l_IdoNFold ) THEN
            WRITE(numicb,*) 'north fold destination points '
            WRITE(numicb,*) nicbfldpts
            WRITE(numicb,*) 'north fold destination procs  '
            WRITE(numicb,*) nicbflddest
            WRITE(numicb,*) 'north fold destination proclist  '
            WRITE(numicb,*) nicbfldproc
            WRITE(numicb,*) 'north fold border j-index  '
            WRITE(numicb,*) nicbfldborder

         ENDIF
         CALL flush(numicb)
      ENDIF
      
      src_calving     (:,:) = 0._wp
      src_calving_hflx(:,:) = 0._wp

      ! assign each new iceberg with a unique number constructed from the processor number
      ! and incremented by the total number of processors
      num_bergs(:) = 0
      num_bergs(1) = narea - jpnij
      
      ! stop NEMO if (nn_test_icebergs <= 0), while using the test_icebergs option
      IF( ( ln_use_test ) .AND. ( nn_test_icebergs <= 0 ) ) CALL ctl_stop('icbini: You are using the test-icebergs option but the number of icebergs is 0 or negative')

      IF( ( .NOT. ln_use_test )  .AND. (  .NOT. ln_use_calving ) )  THEN   ! this if-condition is the default case :
                                                                 ! the user did not write any parameter in namelist_cfg
                                                                 ! so there is no iceberg source in the namelist

         ! if no restart to be read at first time step (which could contain icebergs), send E R R O R and STOP Nemo 
         IF (  ( kt == 1 )  .AND. ( .NOT. ln_rstart ) ) THEN
            CALL ctl_stop('icbini: You are using the Iceberg module but there is no iceberg source at all, so STOP ! you are wasting your time !!')

         ! else (explicitely,  If kt > 1 or if there is a restart to be read), just leave a warning
         ELSE
                 
            WRITE(numout,*)
            WRITE(numout,*) '    W A R N I N G !!!'
            WRITE(numout,*)
            WRITE(numout,*) '    ==>>> icbini: there is no iceberg source in the namelist (see namberg) !!'
         
         ENDIF
      ENDIF
      
      ! when not generating test icebergs we need to setup calving file
      IF( ln_use_calving ) THEN
         !
         ! maximum distribution class array does not change in time so read it once
         cl_sdist = TRIM( cn_dir )//TRIM( sn_icb%clname )
         CALL iom_open ( cl_sdist, inum )                              ! open file
         ivar = iom_varid( inum, 'maxclass', ldstop=.FALSE. )
         IF( ivar > 0 ) THEN
            CALL iom_get  ( inum, jpdom_global, 'maxclass', src_calving )   ! read the max distribution array
            berg_grid%maxclass(:,:) = INT( src_calving )
            src_calving(:,:) = 0._wp
         ENDIF
         CALL iom_close( inum )                                     ! close file
         !
         IF( nn_verbose_level > 0) THEN
            WRITE(numicb,*)
            WRITE(numicb,*) '          calving read in a file'
         ENDIF
         ALLOCATE( sf_icb(1), STAT=istat1 )         ! Create sf_icb structure (calving)
         ALLOCATE( sf_icb(1)%fnow(jpi,jpj,1), STAT=istat2 )
         ALLOCATE( sf_icb(1)%fdta(jpi,jpj,1,2), STAT=istat3 )
         IF( istat1+istat2+istat3 > 0 ) THEN
            CALL ctl_stop( 'sbc_icb: unable to allocate sf_icb structure' )   ;   RETURN
         ENDIF
         !                                          ! fill sf_icb with the namelist (sn_icb) and control print
         CALL fld_fill( sf_icb, (/ sn_icb /), cn_dir, 'icb_init', 'read calving data', 'namicb' )
         !
      ENDIF 
      !
      IF( ln_use_test )   CALL icb_ini_gen( Kmm )
      !
      IF( ln_rstart ) THEN
         CALL icb_rst_read()
         l_restarted_bergs = .TRUE.
      END IF
      !
      IF( nn_sample_rate .GT. 0 ) CALL icb_trj_init( nitend )
      !
      CALL icb_dia_init()
      !
      IF( nn_verbose_level >= 2 )   CALL icb_utl_print('icb_init, initial status', nit000-1)
      !
   END SUBROUTINE icb_init


   SUBROUTINE icb_ini_gen( Kmm )
      !!----------------------------------------------------------------------
      !!                  ***  ROUTINE icb_ini_gen  ***
      !!
      !! ** Purpose :   iceberg generation
      !!
      !! ** Method  : - at each grid point of the test box supplied in the namelist
      !!                generate an iceberg in one class determined by the value of
      !!                parameter nn_test_icebergs
      !!----------------------------------------------------------------------
      !
      INTEGER, INTENT(in) :: Kmm      ! ocean time level indices
      !
      INTEGER                         ::   ji, jj, ibergs
      TYPE(iceberg)                   ::   localberg ! NOT a pointer but an actual local variable
      TYPE(point)                     ::   localpt
      INTEGER                         ::   iyr, imon, iday, ihr, imin, isec
      INTEGER                         ::   iberg
      !!----------------------------------------------------------------------

      ! For convenience
      iberg = nn_test_icebergs

      ! call get_date(Time, iyr, imon, iday, ihr, imin, isec)
      ! Convert nemo time variables from dom_oce into local versions
      iyr  = nyear
      imon = nmonth
      iday = nday
      ihr = INT(nsec_day/3600)
      imin = INT((nsec_day-ihr*3600)/60)
      isec = nsec_day - ihr*3600 - imin*60

      ! no overlap for icebergs since we want only one instance of each across the whole domain
      ! so restrict area of interest
      ! use tmask here because tmask_i has been doctored on one side of the north fold line
      ! (PM) tmask_i added because no iceberg should be on the halo at initialisation

      DO jj = Njs0, Nje0
         DO ji = Nis0, Nie0
            IF( tmask_i(ji,jj)*tmask(ji,jj,1) > 0._wp        .AND.                                       &
                rn_test_box(1) < glamt(ji,jj) .AND. glamt(ji,jj) < rn_test_box(2) .AND.   &
                rn_test_box(3) < gphit(ji,jj) .AND. gphit(ji,jj) < rn_test_box(4) ) THEN
               localberg%mass_scaling = rn_mass_scaling(iberg)
               localpt%xi = REAL( mig(ji,nn_hls) - (nn_hls-1), wp )
               localpt%yj = REAL( mjg(jj,nn_hls) - (nn_hls-1), wp )
               CALL icb_utl_interp( Kmm, localpt%xi, localpt%yj, plat=localpt%lat, plon=localpt%lon )
               localpt%mass      = rn_initial_mass     (iberg)
               localpt%thickness = rn_initial_thickness(iberg)
               localpt%width  = first_width (iberg)
               localpt%length = first_length(iberg)
               localpt%year = iyr
               localpt%day = REAL(iday,wp)+(REAL(ihr,wp)+REAL(imin,wp)/60._wp)/24._wp
               localpt%mass_of_bits = 0._wp
               localpt%heat_density = 0._wp
               localpt%uvel = 0._wp
               localpt%vvel = 0._wp
               localpt%kb   = 1
               CALL icb_utl_incr()
               localberg%number(:) = num_bergs(:)
               call icb_utl_add(localberg, localpt)
            ENDIF
         END DO
      END DO
      !
      ibergs = icb_utl_count()
      CALL mpp_sum('icbini', ibergs)
      IF( nn_verbose_level > 0) THEN
         WRITE(numicb,'(a,i6,a)') 'diamonds, icb_ini_gen: ',ibergs,' were generated'
      ENDIF
      !
   END SUBROUTINE icb_ini_gen


   SUBROUTINE icb_nam
      !!----------------------------------------------------------------------
      !!                     ***  ROUTINE icb_nam  ***
      !!
      !! ** Purpose :   read iceberg namelist and print the variables.
      !!
      !! ** input   : - namberg namelist
      !!----------------------------------------------------------------------
      INTEGER  ::   jn      ! dummy loop indices
      INTEGER  ::   ios     ! Local integer output status for namelist read
      REAL(wp) ::   zfact   ! local scalar
      !
      NAMELIST/namberg/ ln_icebergs    , ln_bergdia     , nn_sample_rate      , rn_initial_mass      ,   &
         &              rn_distribution, rn_mass_scaling, rn_initial_thickness, nn_verbose_write     ,   &
         &              rn_rho_bergs   , rn_LoW_ratio   , nn_verbose_level    , ln_operator_splitting,   &
         &              rn_bits_erosion_fraction        , rn_sicn_shift       , ln_passive_mode      ,   &
         &              ln_time_average_weight          , nn_test_icebergs    , rn_test_box          ,   &
         &              ln_use_calving , rn_speed_limit , cn_dir, sn_icb      , ln_M2016             ,   &
         &              cn_icbrst_indir, cn_icbrst_in   , cn_icbrst_outdir    , cn_icbrst_out        ,   &
         &              ln_icb_grd, ln_use_test
      !!----------------------------------------------------------------------

#if defined key_agrif
      IF(lwp) THEN
         WRITE(numout,*)
         WRITE(numout,*) 'icb_nam : AGRIF is not compatible with namelist namberg :  '
         WRITE(numout,*) '~~~~~~~   definition of rn_initial_mass(nclasses) with nclasses as PARAMETER '
         WRITE(numout,*)
         WRITE(numout,*) '   ==>>>   force  NO icebergs used. The namelist namberg is not read'
      ENDIF
      ln_icebergs = .false.      
      RETURN
#else
      IF(lwp) THEN
         WRITE(numout,*)
         WRITE(numout,*) 'icb_nam : iceberg initialization through namberg namelist read'
         WRITE(numout,*) '~~~~~~~~ '
      ENDIF
#endif   
      !                             !==  read namelist  ==!
      READ_NML_REF(numnam,namberg)
      READ_NML_CFG(numnam,namberg)
      IF(lwm) WRITE ( numond, namberg )
      !
      IF(lwp) WRITE(numout,*)
      IF( ln_icebergs ) THEN
         IF(lwp) WRITE(numout,*) '   ==>>>   icebergs are used'
      ELSE
         IF(lwp) WRITE(numout,*) '   ==>>>   No icebergs used'
         RETURN
      ENDIF
      !
      IF( nn_test_icebergs > nclasses ) THEN
         IF(lwp) WRITE(numout,*)
         IF(lwp) WRITE(numout,*) '   ==>>>   Resetting of nn_test_icebergs to ', nclasses
         nn_test_icebergs = nclasses
      ENDIF
      !
      IF(lwp) THEN                  ! control print
         WRITE(numout,*)
         WRITE(numout,*) 'icb_nam : iceberg initialization through namberg namelist read'
         WRITE(numout,*) '~~~~~~~~ '
         WRITE(numout,*) '   Calculate budgets                                            ln_bergdia       = ', ln_bergdia
         WRITE(numout,*) '   Period between sampling of position for trajectory storage   nn_sample_rate = ', nn_sample_rate
         WRITE(numout,*) '   Mass thresholds between iceberg classes (kg)                 rn_initial_mass     ='
         DO jn = 1, nclasses
            WRITE(numout,'(a,f15.2)') '                                                                ', rn_initial_mass(jn)
         ENDDO
         WRITE(numout,*) '   Fraction of calving to apply to this class (non-dim)         rn_distribution     ='
         DO jn = 1, nclasses
            WRITE(numout,'(a,f10.4)') '                                                                ', rn_distribution(jn)
         END DO
         WRITE(numout,*) '   Ratio between effective and real iceberg mass (non-dim)      rn_mass_scaling     = '
         DO jn = 1, nclasses
            WRITE(numout,'(a,f10.2)') '                                                                ', rn_mass_scaling(jn)
         END DO
         WRITE(numout,*) '   Total thickness of newly calved bergs (m)                    rn_initial_thickness = '
         DO jn = 1, nclasses
            WRITE(numout,'(a,f10.2)') '                                                                ', rn_initial_thickness(jn)
         END DO
         WRITE(numout,*) '   Timesteps between verbose messages                           nn_verbose_write    = ', nn_verbose_write

         WRITE(numout,*) '   Density of icebergs                           rn_rho_bergs  = ', rn_rho_bergs
         WRITE(numout,*) '   Initial ratio L/W for newly calved icebergs   rn_LoW_ratio  = ', rn_LoW_ratio
         WRITE(numout,*) '   Turn on more verbose output                          level  = ', nn_verbose_level
         WRITE(numout,*) '   Use first order operator splitting for thermodynamics    ',   &
            &                    'use_operator_splitting = ', ln_operator_splitting
         WRITE(numout,*) '   Fraction of erosion melt flux to divert to bergy bits    ',   &
            &                    'bits_erosion_fraction = ', rn_bits_erosion_fraction

         WRITE(numout,*) '   Use icb module modification from Merino et al. (2016) : ln_M2016 = ', ln_M2016
         WRITE(numout,*) '       ground icebergs if icb bottom lvl hit the oce bottom level : ln_icb_grd = ', ln_icb_grd
         
         WRITE(numout,*) '   Shift of sea-ice concentration in erosion flux modulation ',   &
            &                    '(0<sicn_shift<1)    rn_sicn_shift  = ', rn_sicn_shift
         WRITE(numout,*) '   Do not add freshwater flux from icebergs to ocean                ',   &
            &                    '                  passive_mode            = ', ln_passive_mode
         WRITE(numout,*) '   Time average the weight on the ocean   time_average_weight       = ', ln_time_average_weight
         WRITE(numout,*) '   Use the iceberg test option                         ln_use_test  = ', ln_use_test
         WRITE(numout,*) '   Create icebergs in absence of a restart file   nn_test_icebergs  = ', nn_test_icebergs
         WRITE(numout,*) '                   in lon/lat box                                   = ', rn_test_box
         WRITE(numout,*) '   Use calving data option                          ln_use_calving  = ', ln_use_calving
         WRITE(numout,*) '   CFL speed limit for a berg            speed_limit                = ', rn_speed_limit
         WRITE(numout,*) '   Writing Iceberg status information to icebergs.stat file        '
      ENDIF
      !
      ! ensure that the sum of berg input distribution is equal to one
      zfact = SUM( rn_distribution )
      IF( zfact /= 1._wp .AND. 0_wp /= zfact ) THEN
         rn_distribution(:) = rn_distribution(:) / zfact
         IF(lwp) THEN
            WRITE(numout,*)
            WRITE(numout,*) '      ==>>> CAUTION:    sum of berg input distribution = ', zfact
            WRITE(numout,*) '            *******     redistribution has been rescaled'
            WRITE(numout,*) '                        updated berg distribution is :'
            DO jn = 1, nclasses
               WRITE(numout,'(a,f10.4)') '                                   ',rn_distribution(jn)
            END DO
         ENDIF
      ENDIF
      IF( MINVAL( rn_distribution(:) ) < 0._wp ) THEN
         CALL ctl_stop( 'icb_nam: a negative rn_distribution value encountered ==>> change your namelist namberg' )
      ENDIF
      !
      ! ensure that nn_verbose_write is a multiple of nn_fsbc
      IF (MOD(nn_verbose_write, nn_fsbc) /= 0) THEN
         CALL ctl_stop( 'icb_nam: nn_verbose_write is not a multiple of nn_fsbc')
      END IF
      !
      ! ensure that nn_sample_rate is a multiple of nn_fsbc
      IF (MOD(nn_sample_rate, nn_fsbc) /= 0) THEN
         CALL ctl_stop( 'icb_nam: nn_sample_rate is not a multiple of nn_fsbc')
      END IF
      !
   END SUBROUTINE icb_nam

   !!======================================================================
END MODULE icbini
